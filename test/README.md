# Testing and Development

This directory contains `note-c` unit-tests written in C++, using Catch2. The
[Fake Function Framework](https://github.com/meekrosoft/fff) (fff) is used for
mocking and is bundled with the test code (see fff.h).

> _**WARNING:** DO NOT STORE FILES `${note-c}/build`! It should be viewed as a
temporary folder, used to facilitate development, that can and will be destroyed
and recreated many times throughout the testing and development process._

## Dependencies

- [CMake](https://cmake.org/install), version 3.20+.
- [Catch2](https://github.com/catchorg/Catch2), v3.
  - CMake will attempt to download and build Catch2 from source.
  - We require C++14, which is the minimum expected by Catch2 v3.

The complete environment required for development is codified in the Dockerfile
in this repository. While, using Docker is not a hard requirement, the container
is consumed by the GitHub CI and is guaranteed to provide all dependencies and a
working development environment.

## Scripts

The scripts folder houses several shell scripts used to facilitate the
development process.

### Testing and Validation

- `check_libc_dependencies.sh`

    Checks for dependencies on non-whitelisted `libc` functions. The whitelist
    is maintained inside the script.

- `run_astyle.sh`

    Runs the astyle linter to ensure the code is properly formatted.

- `run_cppcheck.sh`

    Runs cppcheck to perform static analysis over the codebase.

- `run_unit_tests.sh`

    Builds and runs unit-tests. See [Running Unit-Tests](#running-unit-tests)
    for more information.

### Hardware in the Loop Testing

- `run_md5srv.sh`

    Launches an MD5 server used to validate file transfers generated by
    `card.binary` transactions and verify their integrity.

- `run_ngrok.sh`

    Creates a tunnel to the open internet (a public URL) for the MD5 server
    created by the `run_md5srv.sh` shell script. The URL will be echoed to
    the screen, as well as supplied to the CI environment when called as part
    of the continuous integration test pipeline.

### Documentation

- `build_docs.sh`

    Builds the API documentation in `${note-c}/build/docs`. Open `index.html`
    in your browser to review documentation.

    > _**NOTE:** In order for an API to be considered for inclusion in the API
    documentation, it _MUST_ be added to `${note-c}/docs/api_reference.rst`
    file._

## Testing

### Running Unit-Tests

The unit-tests are designed to be exercised via `run_unit_tests.sh`.

When no parameters are provided to the script, it will simply build and run the
unit-test. However, there are several flags that can be passed to modify the
basic behavior.

- `--coverage`

    Generates the `${note-c}/build/test/coverage/lcov.info` during test
    execution.

    > _**NOTE:** In order to view the coverage results, you will need to change
    into the  run the `${note-c}/build/test/coverage` directory and run the
    command `genhtml lcov.info -o tmp`. If you wish to view the test results in
    your browser, open `file:///${note-c}/build/test/coverage/tmp/index.html`._

- `--low-mem`

    Builds and runs the unit-tests with the `NOTE_C_LOW_MEM` flag present, to
    ensure all code paths still compile and pass tests.

- `--mem-check`

    Builds and runs the unit-tests under `valgrind`, to ensure no memory leaks
    are uncovered during test execution.

- `--show-malloc`

    Builds and runs the unit-tests with the `NOTE_C_SHOW_MALLOC` flag present,
    to ensure all code paths still compile and pass tests.

- `--single-precision`

    Builds and runs the unit-tests with the `NOTE_C_SINGLE_PRECISION` flag
    present, to ensure all code paths still compile and pass tests. When this
    flag is present, all double-precision values are forced to single-precision.
    Some platforms (like AVR) do not provide a 64-bit double precision type.
    On such platforms, `double` is typically implemented as `float`.

- `--verbose`

    Provides comprehensive build logs to assist in test debugging.

#### Interfacing with CMake Directly

The `CMakeList.txt` and the CMake build system are used to compile `note-c` into
a library and to link that library against the unit-tests.

You can use it to generate a static or shared `note-c` library, but embedded
users will typically just compile all the `.c` source files into their firmware
image.

```sh
mkdir build
cd build
cmake ..
make -j
ctest
```

> _**WARNING:** We forbid in-source builds, so creating a build directory (e.g.
`mkdir build`) and building there is mandatory._

#### CMake Options

- `-DNOTE_C_BUILD_DOCS:BOOL=ON`: Build the tests (Default: `ON`).
- `-DNOTE_C_COVERAGE:BOOL=ON`: Adds the target `coverage` to the build. Requires
lcov. To generate a coverage report, run `make coverage` (Default: `OFF`).
- `-DNOTE_C_LOW_MEM:BOOL=ON`: Runs the unit-tests over code compiled with the
`NOTE_C_LOW_MEM` flag enabled. This flag modifies the behavior of the library
to perform better on low memory hosts (Default: `OFF`).
- `-DNOTE_C_MEM_CHECK:BOOL=ON`: Runs the unit-tests under `valgrind` to test for
memory leaks (Default: `OFF`).
- `-DNOTE_C_SHOW_MALLOC:BOOL=ON`: Runs the unit-tests over code compiled with
the `NOTE_C_SHOW_MALLOC` flag enabled. This flag causes the host to log with
each memory allocation and free (Default: `OFF`).
- `-DNOTE_C_SINGLE_PRECISION:BOOL=ON`: Runs the unit-tests over code compiled
with the `NOTE_C_SINGLE_PRECISION` flag enabled. All doubles are treated as
single precision, which is commonplace on many MCUs (Default: `OFF`).
- `-DCMAKE_VERBOSE_MAKEFILE:BOOL=ON --log-level=VERBOSE`: Increase the verbosity
of the build system (Default: `OFF`).

### Organization

Generally, each function in the API gets its own test executable in `test/src`.
The naming convention is `FunctionName_test.cpp`. Some functions make sense to
test together, like the `NotePayload*` family, so they're exercised in one
executable (`NotePayload_test.cpp`, in this case). All newly created test MUST
be added to `test/CMakeLists.txt` with a call to the `add_test` macro.

### Style

#### `CHECK` vs. `REQUIRE`

[Catch2 offers 2 primary assertion macros]
(https://github.com/catchorg/Catch2/blob/devel/docs/assertions.md): `REQUIRE`
and `CHECK`. We prefer `CHECK` anywhere you need to assert something in a test
case. However, if it doesn't make sense or it would cause a fault to continue a
test case, `REQUIRE` should be used to exit the case immediately on failure.

Example:

```cpp
REQUIRE(sizeof(expectedBuf) == actualLength);
CHECK(!memcmp(expectedBuf, actualBuf, actualLength));
```

Here we don't want to continue if the lengths of the two buffers differ, as the
`memcmp` may segfault.
